FUNCTION Z_RKD_WORD_WRAP.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(TEXTLINE) TYPE  C
*"     VALUE(DELIMITER) TYPE  C DEFAULT SPACE
*"     VALUE(OUTPUTLEN) TYPE  I DEFAULT 35
*"  EXPORTING
*"     VALUE(OUT_LINE1) TYPE  C
*"     VALUE(OUT_LINE2) TYPE  C
*"     VALUE(OUT_LINE3) TYPE  C
*"     VALUE(OUT_LINE4) TYPE  C
*"  TABLES
*"      OUT_LINES OPTIONAL
*"  EXCEPTIONS
*"      OUTPUTLEN_TOO_LARGE
*"----------------------------------------------------------------------

* complete re-design with note 1307869
  CONSTANTS: MAX_OUTPUTLEN TYPE I VALUE 256.

  data: ld_line(max_outputlen) type c,
        ld_str_len type i,
        ld_fieldlen type i,
        begin of lt_lines occurs 0,
          line(256) type c,
        end of lt_lines.

* initial checks
  if outputlen gt max_outputlen.
    raise outputlen_too_large.
  endif.
  describe field textline length ld_fieldlen in character mode.
  if ld_fieldlen lt outputlen.
    outputlen = ld_fieldlen.
  endif.

* check for split-option
  ld_str_len = strlen( textline ).
  if delimiter eq space or
     ld_str_len gt outputlen.
*   complex split: last occurrence of delimiter before split-position
    perform split_complex tables lt_lines
                           using textline
                                 outputlen
                                 delimiter.
  else.
*   do a simple split with the delimiter
    split textline at delimiter into table lt_lines
                      in character mode.
  endif.

* fill the return parameters
  loop at lt_lines.
    case sy-tabix.
      when 1. out_line1 = lt_lines-line.
      when 2. out_line2 = lt_lines-line.
      when 3. out_line3 = lt_lines-line.
      when 4. out_line4 = lt_lines-line.
    endcase.
    ld_line = lt_lines-line.
    append ld_line to out_lines.
  endloop.

ENDFUNCTION.
*&---------------------------------------------------------------------*
*&      Form  SPLIT_COMPLEX      "new with note 1307869
*&---------------------------------------------------------------------*
*       split the ID_TEXT at last delimiter ID_DEL with a maximum
*       length ID_LEN
*&---------------------------------------------------------------------*
form split_complex tables ct_lines
                    using id_text type c
                          id_len  type i
                          id_del  type c.

  data: ld_len         type i,
        ld_pos         type i,
        ld_strlen      type i.
*        ld_string(256) type c.

  field-symbols: <ld_char> type c,
                 <ld_string> type c.                        "H1407684

  assign id_text to <ld_string>.                            "H1407684
  refresh ct_lines.
* get starting position
  CL_SCP_LINEBREAK_UTIL=>STRING_SPLIT_AT_POSITION(
           exporting im_string   = <ld_string>              "H1407684
                     im_pos_tech = id_len
           importing ex_pos_tech = ld_pos ).
* check each single character - processing rigth to left
  do.
*   check for exit
    ld_strlen = strlen( <ld_string> ).                      "H1407684
    ld_len = ld_pos.
    ld_pos = ld_pos - 1.
    if ld_pos lt 0 or ld_strlen eq 0.
      exit.
    endif.
*   get actual character
    CL_SCP_LINEBREAK_UTIL=>STRING_SPLIT_AT_POSITION(
             exporting im_string   = <ld_string>            "H1407684
                       im_pos_tech = ld_pos
             importing ex_pos_tech = ld_pos ).
    ld_len = ld_len - ld_pos.
    assign <ld_string>+ld_pos(ld_len) to <ld_char> casting. "H1407684
*   check actual character
    if ( <ld_char> eq id_del and ld_pos ne 0 ) or
       ( ld_strlen le id_len ).
*     delimiter found or string is short enough
      if ld_pos gt 0.                                       "H1365149
        concatenate <ld_string>(ld_pos) <ld_char>           "H1407684
                       into ct_lines RESPECTING BLANKS.     "H1355908
      else.                                                 "H1365149
        ct_lines = <ld_char>.                               "H1365149
      endif.                                                "H1365149
      append ct_lines.
      shift <ld_string> by ld_pos places.                   "H1407684
      shift <ld_string> by ld_len places.                   "H1407684
      CL_SCP_LINEBREAK_UTIL=>STRING_SPLIT_AT_POSITION(
               exporting im_string   = <ld_string>          "H1407684
                         im_pos_tech = id_len
               importing ex_pos_tech = ld_pos ).
    elseif ld_pos = 0.
*     no delimiter found - do a break at ID_LEN
      CL_SCP_LINEBREAK_UTIL=>STRING_SPLIT_AT_POSITION(
               exporting im_string   = <ld_string>          "H1407684
                         im_pos_tech = id_len
               importing ex_pos_tech = ld_pos ).
      ct_lines = <ld_string>(ld_pos).                       "H1407684
      append ct_lines.
      shift <ld_string> by ld_pos places.                   "H1407684
      CL_SCP_LINEBREAK_UTIL=>STRING_SPLIT_AT_POSITION(
               exporting im_string   = <ld_string>          "H1407684
                         im_pos_tech = id_len
               importing ex_pos_tech = ld_pos ).
    endif.
  enddo.

endform.

************************************************************************

class ZCX_HTTP definition
  public
  inheriting from CX_STATIC_CHECK
  create public .

public section.

  interfaces IF_T100_DYN_MSG .
  interfaces IF_T100_MESSAGE .

  aliases DEFAULT_TEXTID
    for IF_T100_MESSAGE~DEFAULT_TEXTID .
  aliases MSGTY
    for IF_T100_DYN_MSG~MSGTY .
  aliases MSGV1
    for IF_T100_DYN_MSG~MSGV1 .
  aliases MSGV2
    for IF_T100_DYN_MSG~MSGV2 .
  aliases MSGV3
    for IF_T100_DYN_MSG~MSGV3 .
  aliases MSGV4
    for IF_T100_DYN_MSG~MSGV4 .
  aliases T100KEY
    for IF_T100_MESSAGE~T100KEY .

  methods CONSTRUCTOR
    importing
      !TEXTID like IF_T100_MESSAGE=>T100KEY optional
      !PREVIOUS like PREVIOUS optional
      !MSGTY type SYMSGTY optional
      !MSGV1 type SYMSGV optional
      !MSGV2 type SYMSGV optional
      !MSGV3 type SYMSGV optional
      !MSGV4 type SYMSGV optional .
  methods GET_MSG
    returning
      value(RT_MSG) type BAPIRET2_TAB .

METHOD get_msg.

  MESSAGE ID me->t100key-msgid TYPE me->msgty NUMBER me->t100key-msgno
  WITH me->msgv1 me->msgv2 me->msgv3 me->msgv4
  INTO DATA(lv_message).

  APPEND VALUE #( type       = me->msgty
                  id         = me->t100key-msgid
                  number     = me->t100key-msgno
                  message_v1 = me->msgv1
                  message_v2 = me->msgv2
                  message_v3 = me->msgv3
                  message_v4 = me->msgv4
                  message    = lv_message ) TO rt_msg.

ENDMETHOD.

************************************************************************

class ZCL_HTTP definition
  public
  create public .

public section.

  class-methods REQUEST
    importing
      !IP_PROTOCOL type STRING default 'https'
      !IP_HOST type STRING
      !IP_ENDPOINT type STRING
      !IP_PROXY_HOST type STRING optional
      !IP_PROXY_PORT type STRING optional
      !IP_METHOD type STRING default IF_HTTP_REQUEST=>CO_REQUEST_METHOD_POST
      !IT_FORM type WDY_KEY_VALUE_LIST optional
    returning
      value(RESPONSE) type STRING
    raising
      ZCX_HTTP .
protected section.
private section.
ENDCLASS.


CLASS ZCL_HTTP IMPLEMENTATION.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Static Public Method ZCL_HTTP=>REQUEST
* +-------------------------------------------------------------------------------------------------+
* | [--->] IP_PROTOCOL                    TYPE        STRING (default ='https')
* | [--->] IP_HOST                        TYPE        STRING
* | [--->] IP_ENDPOINT                    TYPE        STRING
* | [--->] IP_PROXY_HOST                  TYPE        STRING(optional)
* | [--->] IP_PROXY_PORT                  TYPE        STRING(optional)
* | [--->] IP_METHOD                      TYPE        STRING (default =IF_HTTP_REQUEST=>CO_REQUEST_METHOD_POST)
* | [--->] IT_FORM                        TYPE        WDY_KEY_VALUE_LIST(optional)
* | [<-()] RESPONSE                       TYPE        STRING
* | [!CX!] ZCX_HTTP
* +--------------------------------------------------------------------------------------</SIGNATURE>
METHOD request.

  DATA: lo_client TYPE REF TO if_http_client,
        lv_exc    TYPE string.

  cl_http_client=>create_by_url(
    EXPORTING
      url                    = ip_protocol && `://` && ip_host && ip_endpoint
      proxy_host             = ip_proxy_host
      proxy_service          = ip_proxy_port
    IMPORTING
      client                 = lo_client
    EXCEPTIONS
      argument_not_found     = 1
      plugin_not_active      = 2
      internal_error         = 3
      pse_not_found          = 4
      pse_not_distrib        = 5
      pse_errors             = 6
      OTHERS                 = 7 ).
  IF sy-subrc <> 0.
    RAISE EXCEPTION TYPE zcx_http
      MESSAGE ID 'ZPOSAE' TYPE 'E' NUMBER 192 WITH 'create_by_url' '' '' ''.
  ENDIF.

  lo_client->request->set_method( ip_method ).

  lo_client->request->set_header_field( name  = 'User-Agent'
                                        value = 'SAP NetWeaver Application Server (1.0;755)' ).
  lo_client->request->set_header_field( name  = 'Accept'
                                        value = '*/*' ).
  lo_client->request->set_header_field( name  = 'Host'
                                        value = ip_host ).
  lo_client->request->set_header_field( name  = 'Accept-Encoding'
                                        value = 'gzip, deflate, br' ).
  lo_client->request->set_header_field( name  = 'Connection'
                                        value = 'keep-alive' ).
  lo_client->request->set_header_field( name  = 'content-type'
                                        value = 'application/x-www-form-urlencoded' ).

  DATA lv_length TYPE i.
  LOOP AT it_form ASSIGNING FIELD-SYMBOL(<ls_form>).
    lv_length = lv_length + strlen( <ls_form>-key ).
    lv_length = lv_length + strlen( <ls_form>-value ).
    lo_client->request->set_form_field( name  = <ls_form>-key
                                        value = <ls_form>-value ).
  ENDLOOP.
  lv_length = lv_length + lines( it_form ) * 2 - 1.

  lo_client->request->set_header_field( name  = 'Content-Length'
                                        value = condense( CONV string( lv_length ) ) ).

  lo_client->send(
    EXCEPTIONS
      http_communication_failure = 1
      http_invalid_state         = 2
      http_processing_failed     = 3
      http_invalid_timeout       = 4
      OTHERS                     = 5 ).
  IF sy-subrc <> 0.
    RAISE EXCEPTION TYPE zcx_http
      MESSAGE ID 'ZPOSAE' TYPE 'E' NUMBER 192 WITH 'send' '' '' ''.
  ENDIF.

  lo_client->receive(
    EXCEPTIONS
      http_communication_failure = 1
      http_invalid_state         = 2
      http_processing_failed     = 3
      OTHERS                     = 4 ).
  IF sy-subrc <> 0.
    DATA lv_code           TYPE sysubrc.
    DATA lv_message        TYPE string.
    DATA lv_message_class  TYPE arbgb.
    DATA lv_message_number TYPE msgnr.
    lo_client->get_last_error(
      IMPORTING
        code           = lv_code
        message        = lv_message
        message_class  = lv_message_class
        message_number = lv_message_number ).
    DATA: lv_field1 TYPE c LENGTH 50,
          lv_field2 TYPE c LENGTH 50,
          lv_field3 TYPE c LENGTH 50,
          lv_field4 TYPE c LENGTH 50.
    CALL FUNCTION 'Z_RKD_WORD_WRAP'
      EXPORTING
        textline            = CONV line1024( lv_message )
        outputlen           = 50
      IMPORTING
        out_line1           = lv_field1
        out_line2           = lv_field2
        out_line3           = lv_field3
        out_line4           = lv_field4
      EXCEPTIONS
        outputlen_too_large = 1
        OTHERS              = 2.
    RAISE EXCEPTION TYPE zcx_http
      MESSAGE ID 'ZPOSAE' TYPE 'E' NUMBER 000 WITH lv_field1 lv_field2 lv_field3 lv_field4.
  ENDIF.

*  DATA(lv_xstring) = lo_client->response->get_data( ).
  response = lo_client->response->get_cdata( ).

  lo_client->close( ).

ENDMETHOD.
ENDCLASS.

**********************************************************************************************

class ZCL_JSON definition
  public
  create public .

public section.

  class-methods GET_STRING
    importing
      !REF type ref to DATA
      !ATTRIB type STRING
    returning
      value(VAL) type STRING .
protected section.
private section.
ENDCLASS.



CLASS ZCL_JSON IMPLEMENTATION.


* <SIGNATURE>---------------------------------------------------------------------------------------+
* | Static Public Method ZCL_JSON=>GET_STRING
* +-------------------------------------------------------------------------------------------------+
* | [--->] REF                            TYPE REF TO DATA
* | [--->] ATTRIB                         TYPE        STRING
* | [<-()] VAL                            TYPE        STRING
* +--------------------------------------------------------------------------------------</SIGNATURE>
METHOD get_string.

  DATA lr_val TYPE REF TO data.
  FIELD-SYMBOLS <ls_data> TYPE any.

  IF ref IS BOUND.
    ASSIGN ref->* TO <ls_data>.
    ASSIGN COMPONENT attrib OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lr_val>).
    IF sy-subrc = 0.
      lr_val = <lr_val>.
      ASSIGN lr_val->* TO FIELD-SYMBOL(<lv_val>).
      val = <lv_val>.
    ENDIF.
  ENDIF.

ENDMETHOD.
ENDCLASS.

*******************************************************************************************************

FUNCTION z_cdc_get_token.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  EXPORTING
*"     REFERENCE(TOKEN) TYPE  STRING
*"     REFERENCE(ET_RETURN) TYPE  BAPIRET2_TAB
*"----------------------------------------------------------------------

  DATA: lv_apikey  TYPE string,
        lv_userkey TYPE string,
        lv_secret  TYPE string.

  SELECT SINGLE low FROM tvarvc INTO lv_apikey  WHERE name = 'Z_CDC_APIKEY'.
  SELECT SINGLE low FROM tvarvc INTO lv_userkey WHERE name = 'Z_CDC_USERKEY'.
  SELECT SINGLE low FROM tvarvc INTO lv_secret  WHERE name = 'Z_CDC_SECRET'.

  TRY.
      DATA(lv_response) = zcl_http=>request( ip_host       = 'socialize.eu1.gigya.com'
                                             ip_endpoint   = '/socialize.getToken'
                                             ip_proxy_host = 'proxy'
                                             ip_proxy_port = '3128'
                                             it_form       = VALUE #( ( key = 'grant_type' value = 'none' )
                                                                      ( key = 'client_id'  value = lv_apikey )
                                                                      ( key = 'userKey'    value = lv_userkey )
                                                                      ( key = 'secret'     value = lv_secret ) ) ).
    CATCH zcx_http INTO DATA(lr_http_error).
      et_return = lr_http_error->get_msg( ).
      RETURN.
  ENDTRY.

  token = zcl_json=>get_string( ref    = /ui2/cl_json=>generate( json = lv_response )
                                attrib = 'ACCESS_TOKEN' ).

ENDFUNCTION.